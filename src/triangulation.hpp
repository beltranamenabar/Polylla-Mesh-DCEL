// https://jerryyin.info/geometry-processing-algorithms/half-edge/
// https://doc.cgal.org/latest/Arrangement_on_surface_2/classCGAL_1_1Arrangement__2_1_1Halfedge.html
// https://threejs.org/docs/#examples/en/math/convexhull/HalfEdge.vertex


// half-edge triangulation
/*
Basic operations
    incident_face(e): return the face incident to e
    twin(e): return the twin half-edge of e
    next(e): return the next half-edge of e
    prev(e): return the previous half-edge of e
    origin(e): return the first vertex of half-edge e
    target(e): return the second vertex of half-edge e
Others
    CCW_edge_to_vertex(e): return the next CCW edge incident to v after e
    edge_of_vertex(v): return A edge incident to v
    is_border_face(e): return true if the incident face of e is a border face
    is_interior(e): return true if the incident face of e is an interior face
    is_border_vertex(e): return true if the vertex v is part of the boundary
    faces(): return number of faces
    get_n_half_edges(): Return number of half-edges
    get_n_vertices(): Return number of vertices
    get_Triangles(): bit-vector of triangles where true if the half-edge generate a unique face,
        false if the face is generated by another half-edge
    get_PointX(int i): return the i-th x coordinate of the triangulation
    get_PointY(int i): return the i-th y coordinate of the triangulation

TODO:
    edge_iterator;
    face_iterator;
    vertex_iterator;
    copy constructor;
    constructor independent of triangle
*/

#ifndef TRIANGULATION_HPP
#define TRIANGULATION_HPP

#include <array>
#include <cmath>
#include <fstream>
#include <iostream>
#include <sstream>
#include <unordered_map>
#include <vector>

#include "halfedge.hpp"
#include "vertex.hpp"


class Triangulation {

private:

    using triangle = std::array<int, 3>;
    int n_half_edges = 0; //number of half-edges
    int n_faces = 0; //number of faces
    int n_vertices = 0; //number of vertices
    std::vector<Vertex> vertices;
    std::vector<HalfEdge> half_edges; //list of edges
    //std::vector<char> triangle_flags; //list of edges that generate a unique triangles,
    std::vector<int> triangle_list; //list of edges that generate a unique triangles,
    typedef std::pair<int, int> edge;

    //Read node file in .node format and nodes in point vector
    void read_nodes_from_file(const std::string &name) {
        std::ifstream node_file(name);

        if(node_file.is_open()) {
            double a1, a2, a3, a4;
            std::string line;
            node_file >> n_vertices;

            vertices.reserve(n_vertices);
            std::getline(node_file, line); //skip the first line
            while(std::getline(node_file, line)) {
                std::istringstream(line) >> a1 >> a2 >> a3 >> a4;
                Vertex ve;
                ve.x = a2;
                ve.y = a3;
                ve.is_border = (a4 == 1) ? true : false;
                vertices.push_back(ve);
            }
        } else
            std::cout << "Unable to open node file";
        node_file.close();
    }

    //Read triangle file in .ele format and stores it in faces vector
    std::vector<int> read_triangles_from_file(const std::string &name) {
        std::vector<int> faces;
        std::ifstream ele_file(name);

        if(ele_file.is_open()) {
            int a1, a2, a3, a4;
            std::string line;
            ele_file >> n_faces;

            faces.reserve(3 * n_faces);
            std::getline(ele_file, line); //skip the first line
            while(std::getline(ele_file, line)) {
                std::istringstream(line) >> a1 >> a2 >> a3 >> a4;
                faces.push_back(a2);
                faces.push_back(a3);
                faces.push_back(a4);
            }
        } else
            std::cout << "Unable to open node file";
        ele_file.close();

        return faces;
    }

    //Read node file in .node format and nodes in point vector
    std::vector<int> read_neigh_from_file(const std::string &name) {
        std::vector<int> neighs;
        std::ifstream neigh_file(name);


        if(neigh_file.is_open()) {
            int a1, a2, a3, a4;
            std::string line;
            neigh_file >> n_faces;

            neighs.reserve(3 * n_faces);
            std::getline(neigh_file, line); //skip the first line
            while(std::getline(neigh_file, line)) {
                std::istringstream(line) >> a1 >> a2 >> a3 >> a4;
                neighs.push_back(a2);
                neighs.push_back(a3);
                neighs.push_back(a4);
            }
        } else
            std::cout << "Unable to open node file";
        neigh_file.close();
        return neighs;
    }

    //Generate interior half-edges using faces and neigh vectors
    //also associate each vertex with an incident half-edge
    void construct_interior_halfEdges_from_faces_and_neighs(const std::vector<int> &faces, const std::vector<int> &neighs) {
        for(int i = 0; i < n_faces; i++) {
            HalfEdge he0, he1, he2;
            const int index_he0 = i * 3 + 0;
            const int index_he1 = i * 3 + 1;
            const int index_he2 = i * 3 + 2;
            const int v0 = faces.at(3 * i + 0);
            const int v1 = faces.at(3 * i + 1);
            const int v2 = faces.at(3 * i + 2);
            const int n0 = neighs.at(3 * i + 0);
            const int n1 = neighs.at(3 * i + 1);
            const int n2 = neighs.at(3 * i + 2);

            he0.origin = v0;
            he0.target = v1;
            he0.next = index_he1;
            he0.prev = index_he2;
            he0.face = i;
            he0.is_border = (n2 == -1);
            vertices.at(v0).incident_halfedge = index_he0;
            if(n2 != -1) {
                for(int j = 0; j < 3; j++) {
                    if(faces.at(3 * n2 + j) == v1 && faces.at(3 * n2 + (j + 1) % 3) == v0) {
                        he0.twin = 3 * n2 + j;
                        break;
                    }
                }
            } else
                he0.twin = -1;

            half_edges.push_back(he0);

            he1.origin = v1;
            he1.target = v2;
            he1.next = index_he2;
            he1.prev = index_he0;
            he1.face = i;
            he1.is_border = (n0 == -1);

            vertices.at(v1).incident_halfedge = index_he1;


            if(n0 != -1) {
                for(int j = 0; j < 3; j++) {
                    if(faces.at(3 * n0 + j) == v2 && faces.at(3 * n0 + (j + 1) % 3) == v1) {
                        he1.twin = 3 * n0 + j;
                        break;
                    }
                }
            } else
                he1.twin = -1;
            half_edges.push_back(he1);

            he2.origin = v2;
            he2.target = v0;
            he2.next = index_he0;
            he2.prev = index_he1;
            he2.face = i;
            he2.is_border = (n1 == -1);
            vertices.at(v2).incident_halfedge = index_he2;

            if(n1 != -1)
                for(int j = 0; j < 3; j++) {
                    if(faces.at(3 * n1 + j) == v0 && faces.at(3 * n1 + (j + 1) % 3) == v2) {
                        he2.twin = 3 * n1 + j;
                        break;
                    }
                }
            else
                he2.twin = -1;

            half_edges.push_back(he2);
        }

        this->n_half_edges = static_cast<int>(half_edges.size());
    }

    //Generate exterior half-edges
    //Literally calculates the convex hull
    //this takes O(n + k*k), with n the number of interior half-edges and k the number of exterior half-edges
    //optimize to a version n + k
    void construct_exterior_half_edges() {
        //search interior edges labeled as border, generates exterior edges
        //with the origin and target inverted and add at the of HalfEdges vector
        for(int i = 0; i < this->n_half_edges; i++)
            if(half_edges.at(i).is_border) {
                HalfEdge he_aux;
                he_aux.target = half_edges.at(i).origin;
                he_aux.origin = half_edges.at(i).target;
                he_aux.is_border = true;
                half_edges.at(i).is_border = false;
                he_aux.twin = i;
                half_edges.push_back(he_aux);
                half_edges.at(i).twin = static_cast<int>(half_edges.size()) - 1;
            }


        //traverse the exterior edges and search their next prev half-edge
        for(int i = n_half_edges; i < half_edges.size(); i++) {
            if(half_edges.at(i).is_border) {
                //search prev of the half-edge
                for(int j = n_half_edges; j < half_edges.size(); j++)
                    if(half_edges.at(j).origin == half_edges.at(i).target) {
                        half_edges.at(j).prev = i;
                        break;
                    }
                //search next of each exterior edge
                for(int j = n_half_edges; j < half_edges.size(); j++)
                    if(half_edges.at(i).target == half_edges.at(j).origin) {
                        half_edges.at(i).next = j;
                        break;
                    }
            }
        }

        this->n_half_edges = static_cast<int>(half_edges.size());
    }


    //Generate interior half-edges using a a vector with the faces of the triangulation
    //if an interior half-edge is border, it is mark as border-edge
    //mark border-edges
    void construct_interior_half_edges_from_faces(std::vector<int> faces) {
        auto hash_for_pair = [](const std::pair<int, int> &p) {
            return std::hash<int>{}(p.first) ^ std::hash<int>{}(p.second);
        };
        std::unordered_map<edge, int, decltype(hash_for_pair)> map_edges(
        3 * this->n_faces,
        hash_for_pair
        ); //set of edges to calculate the boundary and twin edges
        for(int i = 0; i < n_faces; i++) {
            HalfEdge he0, he1, he2;
            const int index_he0 = i * 3 + 0;
            const int index_he1 = i * 3 + 1;
            const int index_he2 = i * 3 + 2;
            int v0 = faces.at(3 * i + 0);
            int v1 = faces.at(3 * i + 1);
            int v2 = faces.at(3 * i + 2);

            he0.origin = v0;
            he0.target = v1;
            he0.next = index_he1;
            he0.prev = index_he2;
            he0.face = i;
            he0.is_border = false;
            he0.twin = -1;
            // we left the twin unset
            vertices.at(v0).incident_halfedge = index_he0;

            map_edges[std::make_pair(v0, v1)] = index_he0;
            half_edges.push_back(he0);

            he1.origin = v1;
            he1.target = v2;
            he1.next = index_he2;
            he1.prev = index_he0;
            he1.face = i;
            he1.is_border = false;
            he1.twin = -1;
            vertices.at(v1).incident_halfedge = index_he1;

            map_edges[std::make_pair(v1, v2)] = index_he1;
            half_edges.push_back(he1);

            he2.origin = v2;
            he2.target = v0;
            he2.next = index_he0;
            he2.prev = index_he1;
            he2.face = i;
            he2.is_border = false;
            he2.twin = -1;
            vertices.at(v2).incident_halfedge = index_he2;

            map_edges[std::make_pair(v2, v0)] = index_he2;
            half_edges.push_back(he2);
        }
        this->n_half_edges = static_cast<int>(half_edges.size());

        for(int i = 0; i < half_edges.size(); i++) {
            //if half-edge has no twin
            if(half_edges.at(i).twin == -1) {
                edge twin = std::make_pair(half_edges.at(i).target, half_edges.at(i).origin);
                auto it = map_edges.find(twin);
                //if twin is found
                if(it != map_edges.end()) {
                    const int index_twin = it->second;
                    half_edges.at(i).twin = index_twin;
                    half_edges.at(index_twin).twin = i;
                } else { //if twin is not found and half-edge is on the boundary
                    half_edges.at(i).is_border = true;
                    vertices.at(half_edges.at(i).origin).is_border = true;
                    vertices.at(half_edges.at(i).target).is_border = true;
                }
            }
        }
    }

    //Read the mesh from a file in OFF format
    std::vector<int> read_off_file(const std::string &name) {
        //Read the OFF file
        std::vector<int> faces;
        std::ifstream off_file(name);
        if(off_file.is_open()) {
            std::string tmp;
            double a1, a2, a3;
            std::string line;
            //Check first line is a OFF file
            while(std::getline(off_file, line)) {
                //add check boundary vertices flag
                std::istringstream(line) >> tmp;
                if(tmp[0] != '#') //check if first element is a commentary
                {
                    if(tmp[0] == 'O' && tmp[1] == 'F' && tmp[2] == 'F') //Check if the format is OFF
                        break;
                    else {
                        std::cout << "The file is not an OFF file" << std::endl;
                        exit(0);
                    }
                }
            }

            //Read the number of vertices and faces

            while(std::getline(off_file, line)) {
                //add check boundary vertices flag
                std::istringstream(line) >> tmp;
                if(tmp[0] != '#') //check if first element is a commentary
                {
                    std::istringstream(line) >> this->n_vertices >> this->n_faces;
                    this->vertices.reserve(this->n_vertices);
                    faces.reserve(3 * this->n_faces);
                    break;
                }
            }

            //Read vertices
            int index = 0;
            while(index < n_vertices && std::getline(off_file, line)) {
                std::istringstream(line) >> tmp;
                if(tmp[0] != '#') //check if first element is a commentary
                {
                    std::istringstream(line) >> a1 >> a2 >> a3;
                    Vertex ve;
                    ve.x = a1;
                    ve.y = a2;
                    this->vertices.push_back(ve);
                    index++;
                }
            }
            //Read faces

            int length, t1, t2, t3;
            index = 0;
            while(index < n_faces && std::getline(off_file, line)) {
                std::istringstream(line) >> tmp;
                if(tmp[0] != '#') //check if first element is a commentary
                {
                    std::istringstream(line) >> length >> t1 >> t2 >> t3;
                    faces.push_back(t1);
                    faces.push_back(t2);
                    faces.push_back(t3);
                    index++;
                }
            }

        } else
            std::cout << "Unable to open node file";
        off_file.close();
        return faces;
    }


public:

    //default constructor
    Triangulation() = default;

    //Constructor from file
    Triangulation(const std::string &node_file, const std::string &ele_file, const std::string &neigh_file) {
        std::cout << "Reading node file" << std::endl;
        read_nodes_from_file(node_file);
        std::cout << "Reading ele file" << std::endl;
        const std::vector<int> faces = read_triangles_from_file(ele_file);
        std::cout << "Reading neigh file" << std::endl;
        const std::vector<int> neighs = read_neigh_from_file(neigh_file);

        construct_interior_halfEdges_from_faces_and_neighs(faces, neighs);

        construct_exterior_half_edges();

        triangle_list.reserve(n_faces);
        for(int i = 0; i < n_faces; i++) triangle_list.push_back(3 * i);
    }

    Triangulation(const std::string &off_file) {
        std::cout << "Reading OFF file " << off_file << std::endl;
        const std::vector<int> faces = read_off_file(off_file);
        construct_interior_half_edges_from_faces(faces);
        construct_exterior_half_edges();

        triangle_list.reserve(n_faces);
        for(int i = 0; i < n_faces; i++) triangle_list.push_back(3 * i);
    }

    //Constructor from vectors
    Triangulation(std::vector<Vertex> &vertices, std::vector<int> &triangles) {

        this->n_vertices = static_cast<int>(vertices.size());
        this->n_faces = static_cast<int>(triangles.size()) / 3;

        this->vertices = vertices;
        const std::vector<int> faces = triangles;

        construct_interior_half_edges_from_faces(faces);
        construct_exterior_half_edges();

        triangle_list.reserve(n_faces);
        for(int i = 0; i < n_faces; i++) triangle_list.push_back(3 * i);
    }


    //print the triangulation in pg file format
    void print_pg(const std::string &file_name) const {
        std::ofstream file;
        file.open(file_name);
        file << n_vertices << "\n";
        file << n_half_edges << "\n";
        for(int i = 0; i < n_vertices; i++) {
            const Vertex v = vertices.at(i);
            const int incident = v.incident_halfedge;
            int curr = incident;
            int twin = half_edges.at(curr).twin;
            //search border edges with v as origin
            if(v.is_border) {
                while(!half_edges.at(twin).is_border) {
                    curr = ccw_edge_to_vertex(curr);
                    twin = half_edges.at(curr).twin;
                }
            }
            file << origin(curr) << " " << target(curr) << "\n";
            int nxt = ccw_edge_to_vertex(curr);
            while(nxt != curr) {
                file << origin(nxt) << " " << target(nxt) << "\n";
                nxt = ccw_edge_to_vertex(nxt);
            }
        }
        file.close();
    }

    // Calculates the distance of edge e
    double distance(const int e) const {
        const double x1 = vertices.at(origin(e)).x;
        const double y1 = vertices.at(origin(e)).y;
        const double x2 = vertices.at(target(e)).x;
        const double y2 = vertices.at(target(e)).y;
        return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));
    }


    int face_index(const int i) const {
        return half_edges.at(i).face;
    }

    //Return triangle of the face incident to edge e
    //Input: e is the edge
    //output: array with the vertices of the triangle
    triangle incident_face(const int e) const {
        triangle face{};
        int nxt = e;
        const int init_vertex = origin(nxt);
        int curr_vertex = -1;
        int i = 0;
        while(curr_vertex != init_vertex) {
            nxt = next(nxt);
            curr_vertex = origin(nxt);
            face.at(i) = curr_vertex;
            i++;
        }
        return face;
    }

    //function to check if a triangle is counterclockwise
    //Input: array with the vertices of the triangle
    //Output: true if the triangle is counterclockwise, false otherwise
    bool is_counterclockwise(const triangle tr) const {
        const int v0 = tr.at(0);
        const int v1 = tr.at(1);
        const int v2 = tr.at(2);
        double area = 0.0;
        // int val = (p2.y - p1.y) * (p3.x - p2.x) - (p2.x - p1.x) * (p3.y - p2.y);
        area = (vertices.at(v2).x - vertices.at(v1).x) * (vertices.at(v1).y - vertices.at(v0).y)
               - (vertices.at(v2).y - vertices.at(v1).y) * (vertices.at(v1).x - vertices.at(v0).x);
        if(area < 0)
            return true;
        else
            return false;
    }

    //Given a edge with vertex origin v, return the next counterclockwise edge of v with v as origin
    //Input: e is the edge
    //Output: the next counterclockwise edge of v
    int ccw_edge_to_vertex(const int e) const {
        int twn, nxt;
        if(is_border_face(e)) {
            nxt = half_edges.at(e).prev;
            twn = half_edges.at(nxt).twin;
            return twn;
        }
        nxt = half_edges.at(e).next;
        nxt = half_edges.at(nxt).next;
        twn = half_edges.at(nxt).twin;
        return twn;
    }

    //Given a edge with vertex origin v, return the prev clockwise edge of v with v as origin
    //Input: e is the edge
    //Output: the prev clockwise edge of v
    int cw_edge_to_vertex(const int e) const {
        const int twn = half_edges.at(e).twin;
        const int nxt = half_edges.at(twn).next;
        return nxt;
    }

    //return number of faces
    int faces() const {
        return n_faces;
    }

    //Return number of half-edges
    int get_n_half_edges() const {
        return n_half_edges;
    }

    //Return the number of vertices
    int get_n_vertices() const {
        return n_vertices;
    }

    //list of triangles where true if the half-edge generate a unique face, false if the face is generated by another half-edge
    //Replace by a triangle iterator
    std::vector<int> get_triangles() {
        return triangle_list;
    }

    double get_point_x(const int i) const {
        return vertices.at(i).x;
    }

    double get_point_y(const int i) const {
        return vertices.at(i).y;
    }

    //Calculates the next edge of the face incident to edge e
    //Input: e is the edge
    //Output: the next edge of the face incident to e
    int next(const int e) const {
        return half_edges.at(e).next;
    }

    //Calculates the tail vertex of the edge e
    //Input: e is the edge
    //Output: the tail vertex v of the edge e
    int origin(const int e) const {
        return half_edges.at(e).origin;
    }


    //Calculates the head vertex of the edge e
    //Input: e is the edge
    //Output: the head vertex v of the edge e
    int target(const int e) const {
        return half_edges.at(e).target;
    }

    //Return the twin edge of the edge e
    //Input: e is the edge
    //Output: the twin edge of e
    int twin(const int e) const {
        return half_edges.at(e).twin;
    }

    //Return the twin edge of the edge e
    //Input: e is the edge
    //Output: the twin edge of e
    int prev(const int e) const {
        return half_edges.at(e).prev;
    }



    //return a edge associate to the node v
    //Input: v is the node
    //Output: the edge associate to the node v
    int edge_of_vertex(const int v) const {
        return vertices.at(v).incident_halfedge;
    }

    //Input: edge e
    //Output: true if is the face of e is border face
    //        false otherwise
    bool is_border_face(const int e) const {
        return half_edges.at(e).is_border;
    }

    // Input: edge e of compressTriangulation
    // Output: true if the edge is an interior face a
    //         false otherwise
    bool is_interior_face(const int e) const {
        return !this->is_border_face(e);
    }

    //Input:vertex v
    //Output: the edge incident to v, with v as origin
    bool is_border_vertex(const int v) const {
        return vertices.at(v).is_border;
    }
};

#endif