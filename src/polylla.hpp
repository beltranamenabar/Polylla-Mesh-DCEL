/*
 * Polygon mesh generator
 * POSIBLE BUG: el algoritmo no viaja por todos los halfedges dentro de un poligono, 
 * por lo que pueden haber semillas que no se borren y tener poligonos repetidos de output
 */

#ifndef POLYLLA_HPP
#define POLYLLA_HPP

#include <array>
#include <chrono>
#include <cmath>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <string>
#include <vector>

#include "polygon.hpp"
#include "triangulation.hpp"


class Polylla {
private:

    using polygon = std::vector<int>;
    using bit_vector = std::vector<bool>;


    Triangulation *tr; // Half-edge triangulation
    std::vector<Polygon> polygonal_mesh; // Vector of polygons generated by polygon
    std::vector<int> triangles; // True if the edge generated a triangle CHANGE!!!!

    bit_vector max_edges; // True if the edge i is a max edge
    bit_vector frontier_edges; // True if the edge i is a frontier edge
    bit_vector terminal_edges; // True if the edge i is a terminal edge
    std::vector<int> seed_edges; // Seed edges that generate polygon simple and non-simple

    int m_polygons = 0; // Number of polygons
    int n_frontier_edges = 0; // Number of frontier edges
    int n_barrier_edge_tips = 0; // Number of barrier edge tips

public:

    Polylla(const Triangulation &tr) {

        this->tr = new Triangulation(tr);
    }

    //Constructor from a OFF file
    Polylla(const std::string &off_file) {

        const auto t_start = std::chrono::high_resolution_clock::now();
        this->tr = new Triangulation(off_file);
        const auto t_end = std::chrono::high_resolution_clock::now();
        const double elapsed_time_ms = std::chrono::duration<double, std::milli>(t_end - t_start).count();
        std::cout << "Triangulation generated " << elapsed_time_ms << " ms" << std::endl;

        construct_polylla();
    }

    //Constructor from a node_file, ele_file and neigh_file
    Polylla(const std::string &node_file, const std::string &ele_file, const std::string &neigh_file) {

        const auto t_start = std::chrono::high_resolution_clock::now();
        this->tr = new Triangulation(node_file, ele_file, neigh_file);
        const auto t_end = std::chrono::high_resolution_clock::now();
        const double elapsed_time_ms = std::chrono::duration<double, std::milli>(t_end - t_start).count();
        std::cout << "Triangulation generated " << elapsed_time_ms << " ms" << std::endl;

        construct_polylla();
    }

    ~Polylla() {
        delete tr;
    }

    void construct_polylla() {
        max_edges = bit_vector(tr->get_n_half_edges(), false);
        frontier_edges = bit_vector(tr->get_n_half_edges(), false);
        terminal_edges = bit_vector(tr->get_n_half_edges(), false);
        triangles = tr->get_triangles(); //Change by triangle list

        //Label max edges of each triangle
        auto t_start = std::chrono::high_resolution_clock::now();
        for(const auto &t : triangles) {
            max_edges[label_max_edge(t)] = true;
        }
        auto t_end = std::chrono::high_resolution_clock::now();
        double elapsed_time_ms = std::chrono::duration<double, std::milli>(t_end - t_start).count();
        std::cout << "Labeled max edges in " << elapsed_time_ms << " ms" << std::endl;

        t_start = std::chrono::high_resolution_clock::now();
        //Label frontier edges
        for(int e = 0; e < tr->get_n_half_edges(); e++) {
            if(is_frontier_edge(e)) {
                frontier_edges[e] = true;
                n_frontier_edges++;
            }
        }
        t_end = std::chrono::high_resolution_clock::now();
        elapsed_time_ms = std::chrono::duration<double, std::milli>(t_end - t_start).count();
        std::cout << "Labeled frontier edges in " << elapsed_time_ms << " ms" << std::endl;

        t_start = std::chrono::high_resolution_clock::now();
        //label seeds edges,
        for(int e = 0; e < tr->get_n_half_edges(); e++)
            if(tr->is_interior_face(e) && is_seed_edge(e))
                seed_edges.push_back(e);
        t_end = std::chrono::high_resolution_clock::now();
        elapsed_time_ms = std::chrono::duration<double, std::milli>(t_end - t_start).count();
        std::cout << "Labeled seed edges in " << elapsed_time_ms << " ms" << std::endl;


        //Foreach seed edge generate polygon
        t_start = std::chrono::high_resolution_clock::now();
        for(const auto &e : seed_edges) {
            polygon poly = travel_triangles(e);
            if(!has_barrier_edge_tip(poly)) {
                //If the polygon is a simple polygon then is part of the mesh
                polygonal_mesh.push_back({e, poly});
            } else {
                //Else, the polygon is send to reparation phase
                barrier_edge_tip_reparation(poly);
            }
        }
        t_end = std::chrono::high_resolution_clock::now();
        elapsed_time_ms = std::chrono::duration<double, std::milli>(t_end - t_start).count();
        std::cout << "Polygons generated/repaired in " << elapsed_time_ms << " ms" << std::endl;

        this->m_polygons = static_cast<int>(polygonal_mesh.size());

        std::cout << "Mesh with " << m_polygons << " polygons " << n_frontier_edges / 2 << " edges and "
                  << n_barrier_edge_tips << " barrier-edge tips." << std::endl;
    }

    //function whose input is a vector and print the elements of the vector
    static void print_vector(const std::vector<int> &vec) {
        std::cout << vec.size() << " ";
        for(auto &v : vec) {
            std::cout << v << " ";
        }
        std::cout << std::endl;
    }

    //Print ale file of the polylla mesh
    void print_ale(const std::string &filename) const {
        std::ofstream out(filename);
        polygon poly;
        out << "# domain type\nCustom\n";
        out << "# nodal coordinates: number of nodes followed by the coordinates \n";
        out << tr->get_n_vertices() << std::endl;
        //print nodes
        for(int v = 0; v < tr->get_n_vertices(); v++)
            out << std::setprecision(15) << tr->get_point_x(v) << " " << tr->get_point_y(v) << std::endl;
        out << "# element connectivity: number of elements followed by the elements\n";
        out << this->m_polygons << std::endl;
        //print polygons
        for(auto &i : this->polygonal_mesh) {
            out << i.vertices.size() << " ";
            for(auto &v : i.vertices) {
                out << v + 1 << " ";
            }
            out << std::endl;
        }
        //Print border-edges
        out << "# indices of nodes located on the Dirichlet boundary\n";
        ///Find borderedges
        int b_init = 0;
        for(int i = tr->get_n_half_edges() - 1; i != 0; i--) {
            if(tr->is_border_face(i)) {
                b_init = i;
                break;
            }
        }
        out << tr->origin(b_init) + 1 << " ";
        int b_curr = tr->prev(b_init);
        while(b_init != b_curr) {
            out << tr->origin(b_curr) + 1 << " ";
            b_curr = tr->prev(b_curr);
        }
        out << std::endl;
        out << "# indices of nodes located on the Neumann boundary\n0\n";
        out << "# xmin, xmax, ymin, ymax of the bounding box\n";
        double xmax = tr->get_point_x(0);
        double xmin = tr->get_point_x(0);
        double ymax = tr->get_point_y(0);
        double ymin = tr->get_point_y(0);
        //Search min and max coordinates
        for(int v = 0; v < tr->get_n_vertices(); v++) {
            //search range x
            if(tr->get_point_x(v) > xmax)
                xmax = tr->get_point_x(v);
            if(tr->get_point_x(v) < xmin)
                xmin = tr->get_point_x(v);
            //search range y
            if(tr->get_point_y(v) > ymax)
                ymax = tr->get_point_y(v);
            if(tr->get_point_y(v) < ymin)
                ymin = tr->get_point_y(v);
        }
        out << xmin << " " << xmax << " " << ymin << " " << ymax << std::endl;
        out.close();
    }

    //Print off file of the polylla mesh
    void print_OFF(const std::string &filename) const {
        std::ofstream out(filename);
        polygon poly;
        out << "{ appearance  {+edge +face linewidth 2} LIST\n";
        out << "OFF" << std::endl;
        //num_vertices num_polygons 0
        out << std::setprecision(15) << tr->get_n_vertices() << " " << m_polygons << " 0" << std::endl;
        //print nodes
        for(int v = 0; v < tr->get_n_vertices(); v++)
            out << tr->get_point_x(v) << " " << tr->get_point_y(v) << " 0" << std::endl;
        //print polygons
        for(auto &i : polygonal_mesh) {
            out << i.vertices.size() << " ";
            for(auto &v : i.vertices) {
                out << v << " ";
            }
            out << std::endl;
        }
        out << "}" << std::endl;
        out.close();
    }

    //Print a half-edge file
    //The first line of the file is the number of half-edges
    //The rest of the lines are the half-edges with the following format:
    //origin target
    void print_hedge(const std::string &file_name) const {
        std::cout << "Print half-edges" << std::endl;
        std::ofstream file;
        file.open(file_name);
        int num_frontier_edges = 0;
        for(const bool frontier_edge : frontier_edges) {
            if(frontier_edge == true) {
                num_frontier_edges++;
            }
        }
        file << num_frontier_edges << std::endl;
        for(int i = 0; i < tr->get_n_half_edges(); i++) {
            if(frontier_edges[i] == true) {
                file << tr->origin(i) << " " << tr->target(i) << "\n";
            }
        }
        file.close();
    }

    std::vector<Polygon> get_polygonal_mesh() const {
        return this->polygonal_mesh;
    }


    //Return a polygon generated from a seed edge
    polygon generate_polygon(const int e) const {
        polygon poly;
        //search next frontier-edge
        const int e_init = search_frontier_edge(e);
        const int v_init = tr->origin(e_init);
        int e_curr = tr->next(e_init);
        int v_curr = tr->origin(e_curr);
        poly.push_back(v_curr);
        while(e_curr != e_init && v_curr != v_init) {
            e_curr = search_frontier_edge(e_curr);
            //select triangle that contains v_curr as origin
            e_curr = tr->next(e_curr);
            v_curr = tr->origin(e_curr);
            poly.push_back(v_curr);
        }
        return poly;
    }


private:

    //Return true is the edge is terminal-edge or terminal border edge,
    //but it only selects one half-edge as terminal-edge, the half-edge with lowest index is selected
    bool is_seed_edge(const int e) const {
        const int twin = tr->twin(e);

        const bool is_terminal_edge = (tr->is_interior_face(twin) && (max_edges[e] && max_edges[twin]));
        const bool is_terminal_border_edge = (tr->is_border_face(twin) && max_edges[e]);

        if((is_terminal_edge && e < twin) || is_terminal_border_edge) {
            return true;
        }

        return false;
    }


    //Label max edges of all triangles in the triangulation
    //input: edge e incident to a triangle t
    //output: position of edge e in max_edges[e] is labeled as true
    int label_max_edge(const int e) const {
        //Calculates the size of each edge of a triangle

        const double dist0 = tr->distance(e);
        const double dist1 = tr->distance(tr->next(e));
        const double dist2 = tr->distance(tr->next(tr->next(e)));

        short max;
        //Find the longest edge of the triangle
        if((dist0 >= dist1 && dist1 >= dist2) || (dist0 >= dist2 && dist2 >= dist1)) {
            max = 0; //edge face[0]-face[1] is max
        } else if((dist1 >= dist0 && dist0 >= dist2) || (dist1 >= dist2 && dist2 >= dist0)) {
            max = 1; //edge face[1]-face[2] is max
        } else if((dist2 >= dist1 && dist1 >= dist0) || (dist2 >= dist0 && dist0 >= dist1)) {
            max = 2; //edge face[2]-face[0] is max
        } else {
            std::cout << "ERROR: max edge not found" << std::endl;
            exit(0);
        }
        const int init_vertex = tr->origin(e);
        int curr_vertex = -1;
        int nxt = e;
        // Return the index of the edge with the longest edge
        while(curr_vertex != init_vertex) {
            nxt = tr->next(nxt);
            curr_vertex = tr->origin(nxt);
            if(max == 0 && curr_vertex == tr->origin(e)) {
                return nxt;
            }
            if(max == 1 && curr_vertex == tr->origin(tr->next(e))) {
                return nxt;
            }
            if(max == 2 && curr_vertex == tr->origin(tr->next(tr->next(e)))) {
                return nxt;
            }
        }
        return -1;
    }


    //Return true if the edge e is the lowest edge both triangles incident to e
    //in case of border edges, they are always labeled as frontier-edge
    bool is_frontier_edge(const int e) const {
        const int twin = tr->twin(e);
        const bool is_border_edge = tr->is_border_face(e) || tr->is_border_face(twin);
        const bool is_not_max_edge = !(max_edges[e] || max_edges[twin]);
        if(is_border_edge || is_not_max_edge)
            return true;
        return false;
    }

    //Travel in CCW order around the edges of vertex v from the edge e looking for the next frontier edge
    int search_frontier_edge(const int e) const {
        int nxt = e;
        while(!frontier_edges[nxt]) {
            nxt = tr->cw_edge_to_vertex(nxt);
        }
        return nxt;
    }

    //return true if the polygon is not simple
    static bool has_barrier_edge_tip(const std::vector<int> &poly) {
        const int length_poly = static_cast<int>(poly.size());
        for(int i = 0; i < length_poly; i++) {
            const int x = i % length_poly;
            const int y = (i + 2) % length_poly;
            if(poly[x] == poly[y])
                return true;
        }
        return false;
    }

    //generate a polygon from a seed edge
    polygon travel_triangles(const int e) const {
        polygon poly;
        //search next frontier-edge
        const int e_init = search_frontier_edge(e);
        const int v_init = tr->origin(e_init);
        int e_curr = tr->next(e_init);
        int v_curr = tr->origin(e_curr);
        poly.push_back(v_curr);
        //travel inside frontier-edges of polygon
        while(e_curr != e_init && v_curr != v_init) {
            e_curr = search_frontier_edge(e_curr);
            //select edge that contains v_curr as origin
            e_curr = tr->next(e_curr);
            v_curr = tr->origin(e_curr);
            //v_curr is part of the polygon
            poly.push_back(v_curr);
        }
        return poly;
    }

    //Given a barrier-edge tip v, return the middle edge incident to v
    //The function first calculate the degree of v - 1 and then divide it by 2, after travel to until the middle-edge
    //input: vertex v
    //output: edge incident to v
    int search_middle_edge(const int v_bet) const {
        //select frontier-edge of barrier-edge tip
        const int frontier_edge_with_bet = this->search_frontier_edge(tr->edge_of_vertex(v_bet));
        int nxt = tr->cw_edge_to_vertex(frontier_edge_with_bet);
        int adv = 1;
        //calculates the degree of v_bet
        while(nxt != frontier_edge_with_bet) {
            nxt = tr->cw_edge_to_vertex(nxt);
            adv++;
        }
        adv--; //last edge visited is the same with the frontier-edge so it is not counted
        if(adv % 2 == 0) {
            //if the triangles surrounding the BET are even
            adv = adv / 2 - 1;
        } else {
            //if the triangles surrounding the BET are odd, edges are even
            //Choose any edge of the triangle in the middle; prov is choose due to this always exists
            adv = adv / 2;
        }
        //back to traversing the edges of v_bet until select the middle-edge
        nxt = tr->cw_edge_to_vertex(frontier_edge_with_bet);
        //adv--;
        while(adv != 0) {
            nxt = tr->cw_edge_to_vertex(nxt);
            adv--;
        }
        return nxt;
    }

    //Given a seed edge e and a polygon poly generated by e, split the polygon until remove al barrier-edge tips
    //input: seed edge e, polygon poly
    //output: polygon without barrier-edge tips
    void barrier_edge_tip_reparation(const std::vector<int> &poly) {

        //list is initialize
        std::vector<int> triangle_list;
        bit_vector seed_bet_mark(this->tr->get_n_half_edges(), false);
        //look for barrier-edge tips
        for(int i = 0; i < poly.size(); i++) {
            const int x = i;
            const int y = (i + 2) % poly.size();
            if(poly[x] == poly[y]) {
                n_barrier_edge_tips++;
                n_frontier_edges += 2;
                //select edge with bet
                const int v_bet = poly[(i + 1) % poly.size()];
                //middle edge that contains v_bet
                const int middle_edge = search_middle_edge(v_bet);
                int t1 = middle_edge;
                int t2 = tr->twin(middle_edge);
                //edges of middle-edge are labeled as frontier-edge
                this->frontier_edges[t1] = true;
                this->frontier_edges[t2] = true;
                //edges are use as seed edges and saves in a list
                triangle_list.push_back(t1);
                triangle_list.push_back(t2);

                seed_bet_mark[t1] = true;
                seed_bet_mark[t2] = true;
            }
        }
        //generate polygons from seeds,
        //two seeds can generate the same polygon
        //so the bit_vector seed_bet_mark is used to label as false the edges that are already used
        while(!triangle_list.empty()) {
            const int t_curr = triangle_list.back();
            triangle_list.pop_back();
            if(seed_bet_mark[t_curr]) {
                seed_bet_mark[t_curr] = false;
                const polygon poly_curr = generate_repaired_polygon(t_curr, seed_bet_mark);
                //Store the polygon in the as part of the mesh
                this->polygonal_mesh.push_back({t_curr, poly_curr});
            }
        }
    }


    //Generate a polygon from a seed-edge and remove repeated seed from seed_list
    //POSIBLE BUG: el algoritmo no viaja por todos los halfedges dentro de un poligono,
    //por lo que pueden haber semillas que no se borren y tener poligonos repetidos de output
    polygon generate_repaired_polygon(const int e, bit_vector &seed_list) const {
        polygon poly;
        int e_init = e;
        //search next frontier-edge
        while(!frontier_edges[e_init]) {
            e_init = tr->cw_edge_to_vertex(e_init);
            seed_list[e_init] = false;
        }
        const int v_init = tr->origin(e_init);
        int e_curr = tr->next(e_init);
        int v_curr = tr->origin(e_curr);
        poly.push_back(v_curr);
        seed_list[e_curr] = false;
        //seed_list[tr->twin(e_curr)] = false;
        while(e_curr != e_init && v_curr != v_init) {
            while(!frontier_edges[e_curr]) {
                e_curr = tr->cw_edge_to_vertex(e_curr);
                seed_list[e_curr] = false;
            }
            seed_list[e_curr] = false;
            e_curr = tr->next(e_curr);
            v_curr = tr->origin(e_curr);
            poly.push_back(v_curr);
            seed_list[e_curr] = false;
        }
        return poly;
    }
};

#endif
